function [ pressure xmesh,ymesh] = My_omni_directional_int(xmesh,ymesh,ax,ay,discard_rowsANDcolums)
% this code compute the relative pressure from the matiarial accelaration
% xmesh,ymesh are the mesh coordinates generated by meshgrid; 
% ax,ay are the acceleration components in two directions;
% pressure the caculated pressure



% regulate the meshgrid
x_diff=diff(xmesh,2,2);
y_diff=diff(ymesh,2,1);
dx=median(reshape(diff(xmesh,1,2),[],1));
dy=median(reshape(diff(ymesh,1,1),[],1));
if max(max(abs(x_diff)))>10^(-10)||max(max(abs(y_diff)))>10^(-10)   
    if sign(dx)==1
        xvector=max(xmesh(:,1)):dx:min(xmesh(:,end));
    elseif sign(dx)==-1
        xvector=min(xmesh(:,1)):dx:max(xmesh(:,end));
    else errordlg('xmesh is not strictly monotonic!')
    end
    if sign(dy)==1
        yvector=max(ymesh(1,:)):dy:min(ymesh(end,:));
    elseif sign(dy)==-1
        yvector=min(ymesh(1,:)):dy:max(ymesh(end,:));
    else errordlg('ymesh is not strictly monotonic!')
    end
    [xmesh_new,ymesh_new]=meshgrid(xvector,yvector);
    Fx = TriScatteredInterp(reshape(xmesh,[],1),reshape(ymesh,[],1) ,reshape(ax,[],1));
    Fy = TriScatteredInterp(reshape(xmesh,[],1),reshape(ymesh,[],1) ,reshape(ay,[],1));
    ax_new=Fx(xmesh_new,ymesh_new);
    ay_new=Fy(xmesh_new,ymesh_new);
    xmesh=xmesh_new;
    ymesh=ymesh_new;
    ax=ax_new;
    ay=ay_new;
    clear xmesh_new  ymesh_new ax_new ay_new
end

% discard the data on the rim to avoid NaNs
% discard_rowsANDcolums=3;
ax=ax(discard_rowsANDcolums+1:end-discard_rowsANDcolums,discard_rowsANDcolums+1:end-discard_rowsANDcolums);
ay=ay(discard_rowsANDcolums+1:end-discard_rowsANDcolums,discard_rowsANDcolums+1:end-discard_rowsANDcolums);
xmesh=xmesh(discard_rowsANDcolums+1:end-discard_rowsANDcolums,discard_rowsANDcolums+1:end-discard_rowsANDcolums);
ymesh=ymesh(discard_rowsANDcolums+1:end-discard_rowsANDcolums,discard_rowsANDcolums+1:end-discard_rowsANDcolums);

% get pressure on the rim
pressure_temp=cell(size(ax));
pressure=zeros(size(ax));
for ii=1:size(pressure,1)
    if ii==1
       pressure(ii,1)=0;
    else
        pressure(ii,1)=pressure(ii-1,1)+1/2*(ay(ii,1)+ay(ii-1,1))*dy;
    end
end
for jj=2:size(pressure,2)
    pressure(1,jj)=pressure(1,jj-1)+1/2*(ax(1,jj)+ax(1,jj-1))*dx;
    pressure(end,jj)=pressure(end,jj-1)+1/2*(ax(end,jj)+ax(end,jj-1))*dx;
end
for ii=2:size(pressure,1)   
    pressure(ii,end)=pressure(ii-1,end)+1/2*(ay(ii,end)+ay(ii-1,end))*dy;
end

    
pressure1=pressure;
for ii=1:size(pressure_temp,1)
    for jj=1:size(pressure_temp,2)
        pressure_temp{ii,jj}=[];
    end
end
[mm,nn]=size(pressure_temp);
[xmesh_temp,ymesh_temp]=meshgrid(1:mm,1:nn);
boundary_points_index=[reshape([xmesh_temp(1,:),xmesh_temp(end,:),xmesh_temp(2:end-1,1)',xmesh_temp(2:end-1,end)'],[],1),...
    reshape([ymesh_temp(1,:),ymesh_temp(end,:),ymesh_temp(2:end-1,1)',ymesh_temp(2:end-1,end)'],[],1)];
for ii=1:length(boundary_points_index)
    ii
    sart_index=boundary_points_index(ii,:);
    end_index_assemble=boundary_points_index;
    end_index_assemble(ii,:)=[];
    for jj=1:length(end_index_assemble)
        end_index=end_index_assemble(jj,:);
        [ row_index, col_index ] = My_get_int_path( sart_index,end_index );
        sub_idx=[reshape(row_index,[],1), reshape(col_index,[],1)];
        for kk=2:length(sub_idx)-1
            pressure1(row_index(kk),col_index(kk))=pressure1(row_index(kk-1),col_index(kk-1))+1/2*(ax(row_index(kk-1),col_index(kk-1))+ax(row_index(kk),col_index(kk)))*(col_index(kk)-col_index(kk-1))*dx...
                +1/2*(ay(row_index(kk-1),col_index(kk-1))+ay(row_index(kk),col_index(kk)))*(row_index(kk)-row_index(kk-1))*dy;
            pressure_temp{row_index(kk),col_index(kk)}=[pressure_temp{row_index(kk),col_index(kk)},pressure1(row_index(kk),col_index(kk))];
        end
    end
end

for ii=2:size(pressure_temp,1)-1
    for jj=2:size(pressure_temp,2)-1
        pressure(ii,jj)=mean(pressure_temp{ii,jj});
    end
end

pressure=-1*pressure;

end

function [ row_index, col_index, cfit_fun] = My_get_int_path( sart_index,end_index )
% this fuction get the shortest path between sart and end points
% the path are chosen to pass the points which are nearest to the line connecting the start and end points

clear xx yy
if  end_index(2)-sart_index(2)==0&&end_index(1)-sart_index(1)==0
    errordlg('start and end points must be different!')
    error('start and end points must be different!')
elseif end_index(2)-sart_index(2)==0   
    yy=sart_index(1):1*sign(end_index(1)-sart_index(1)):end_index(1);
    xx=sart_index(2)*ones(1,length(yy));
elseif end_index(1)-sart_index(1)==0
    xx=sart_index(2):1*sign(end_index(2)-sart_index(2)):end_index(2);
    yy=sart_index(1)*ones(1,length(xx));
elseif abs(end_index(1)-sart_index(1))<=abs(end_index(2)-sart_index(2))    
    cfit_fun=fit([sart_index(2),end_index(2)]',[sart_index(1),end_index(1)]','poly1');
    yy_temp=cfit_fun(sart_index(2):1*sign(end_index(2)-sart_index(2)):end_index(2));
    xx=sart_index(2):1*sign(end_index(2)-sart_index(2)):end_index(2);
    yy=round(yy_temp);    
else
    cfit_fun=fit([sart_index(1),end_index(1)]',[sart_index(2),end_index(2)]','poly1');
    xx_temp=cfit_fun(sart_index(1):1*sign(end_index(1)-sart_index(1)):end_index(1));
    xx=round(xx_temp);
    yy=sart_index(1):1*sign(end_index(1)-sart_index(1)):end_index(1);
end
col_index=xx;
row_index=yy;

col_index=reshape(col_index,[],1);
row_index=reshape(row_index,[],1);

end

    
